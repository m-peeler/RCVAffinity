package affinity;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;

import java.util.Map.Entry;

/**
 * Edited version of the Matrix class made by Marc and Connor.
 * Can create various adjacency matrices from the election data, namely 
 * a first-preference matrix and an any-preference matrix. 
 * 
 * Has five potential matrices that can be created - {@link #_rankedAny}, 
 * {@link #_rankedSecond}, {@link #_didCompete}, {@link #_couldRankSecond},
 * and {@link #_couldRankFirst}, as selected with boolean arguments in the
 * {@link #Matrices(BallotStream, boolean, boolean, boolean, boolean, boolean)}
 * constructor. 
 * 
 * Can also save these matrices to file.
 * 
 * Once instantiated, matrices are generated by calling {@link #makeMatricies()}.
 * 
 * @author Michael Peeler
 * @version July 31th, 2022
 *
 */

public class Matrices {

	// Matrix instance variables.
	
	/**
	 * A matrix showing the distribution of first and second choice party pairings.
	 */
	private ArrayList<MatrixParty> _rankedSecond;
	/** Indicates whether or not the _rankedSecond matrix will be made. */
	private final boolean _snd;
	/**
	 * A matrix showing the distribution of first choice party parings and the selection 
	 * of any of the other parties at any point in time.
	 */
	private ArrayList<MatrixParty> _rankedAny;
	/** Indicates whether or not the _rankedAny matrix will be made. */
	private final boolean _any;
	/**
	 * A matrix showing on how many ballots two parties competed against each other.
	 */
	private int[][] _didCompete;
	/** Indicates whether or not the _didCompete matrix will be made. */
	private final boolean _cmpt;
	/**
	 * A matrix showing how often a party could have been ranked second, i.e. how many 
	 * ballots where a person chose the first party was the second party a legitimate choice.
	 */
	private int[][] _couldRankSecond;
	/** Indicates whether or not the _couldRankSecond matrix will be made. */
	private final boolean _cldSnd;
	/**
	 * A matrix showing how often a party could have been ranked first based on the second-
	 * choice party; ie, if Liberal was ranked second, on how many ballots could Labor have been
	 * ranked first? Essentially counts the number of ballots that the Second preference was counted in,
	 * and the primary preference appeared on. NOTE: Unlike {@link #_couldRankSecond} or 
	 * {@link #_didCompete}, the second dimension of {@link #_couldRankFirst} is equal
	 * to {@link #getSecSize()} + 1 to store data on ballots with no second preference. 
	 */
	private int[][] _couldRankFirst;
	/** Indicates whether or not the _couldRankFirst matrix will be made. */
	private final boolean _cldFst;

	
	
	// Ballot information instance variables. 
	
	/**
	 * The {@link BallotStream} where the ballots used to create the various matrices are gained from.
	 */
	private BallotStream _info; 

	
	// Categories of analysis information variables.
	
	/**
	 * A list of the total primary votes that each primary option received; in the same order as 
	 * {@link BallotStream#getPrimOptions()} and {@link #getPrimaryOrder()}.
	 */
	private ArrayList<Integer> _primaryTotalVotes;
	/**
	 * A list of the total secondary votes that each secondary option received; in the same order as 
	 * {@link BallotStream#getSecOptions()} and {@link #getSecondaryOrder()}.
	 */
	private ArrayList<Integer> _secondaryTotalVotes;
	/**
	 * Variable to check if all ballots have been added to the matrices.
	 */
	private boolean _filled = false;
	
	private static final String ANY_SPARE_STRING = "Total Votes";
	
	
	// Static variables. 
	
	/** Formats the date and time into yyyy/MM/dd HH:mm:ss. */
	private static final DateTimeFormatter DTF = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");


	/**
	 * Instantiates the matrices. The five booleans indicate which 
	 * matrices will be generated.
	 * @param informer The {@link BallotStream} that ballots will be taken from.
	 * @param any Indicates if the instance should make the matrix which 
	 * counts if a secondary choice appeared anywhere on a primary choice's ballot.
	 * @param snd Indicates if the instance should make the matrix which
	 * counts the second choices of each primary choice.
	 * @param cmpt Indicates if the instance should make the matrix which
	 * counts on how many ballots a specific primary choice competed with a
	 * secondary choice.
	 * @param cldSnd Indicates the total number of ballots where a primary choice
	 * could have pick a secondary choice, factoring in both how many times
	 * the primary choice was picked and how often the primary and potential
	 * secondary choices both appeared on ballots.
	 * @param cldFst Indicates the total number of ballots where a secondary
	 * chould could have come after a primary choice, factoring in both how 
	 * many times the secondary choice was picked secondary and how often the
	 * secondary choice and potential primary choices both appeared on ballots.
	 */
	public Matrices(BallotStream informer, boolean any, boolean snd, boolean cmpt, boolean cldSnd, boolean cldFst) {

		_info 		= informer;
		
		// Immutably stores the five Boolean parameters.
		_any 		= any;
		_snd 		= snd;
		_cmpt 		= cmpt;
		_cldSnd 	= cldSnd;
		_cldFst 	= cldFst;

		int xSize 	= getPrimSize();
		int ySize 	= getSecSize();
		
		// Instantiates the five arrays, as needed.
		
		if (_cmpt) 		_didCompete 		= new int[xSize][ySize];
		if (_cldSnd) 	_couldRankSecond 	= new int[xSize][ySize];
		// Size of _couldRankFirst is one larger to store data on those with
		// no second preference. 
		if (_cldFst) 	_couldRankFirst 	= new int[xSize][ySize + 1]; 
		
		if (_snd) 		_rankedSecond 		= new ArrayList<MatrixParty>();
		if (_any) 		_rankedAny 			= new ArrayList<MatrixParty>();
		
		for (String prim : getPrimaryOrder()) {
			if (_snd) _rankedSecond.add(new MatrixParty(prim, getSecondaryOrder(), StandardBallot.NO_SECOND_CHOICE));
			if (_any) _rankedAny.add(	new MatrixParty(prim, getSecondaryOrder(), ANY_SPARE_STRING));
		}
		
	}
	
	/**
	 * Constructor that defaults to making all matrices, and uses the {@link BallotStream}
	 * as the {@link Matrices}' ballot stream to do so.
	 * @param informer
	 */
	public Matrices(BallotStream informer) { 
		this(informer, true, true, true, true, true);
	}
	
	
	// Methods related to adding the current ballot into the various matrices. 
	
	/**
	 * Adds the current ballot in the {@link BallotStream} to the {@link #_rankedSecond}
	 * matrix.For specifications on how second choices are selected, read the
	 * sepecifications of {@link BallotStream#getSecondaryChoice()}.
	 */
	private void addToSecondChoiceMatrix() {
						
		if (_info.getPrimaryChoice().equals(StandardBallot.INFORMAL_BALLOT)) {
			return;
		}		
		
		_rankedSecond.get(_info.getPrimChoiceIndex()).addSecondPref(_info.getSecondaryChoice());
		
	}
	
	/**
	 * Adds the current ballot in the {@link BallotStream} to the {@link #_rankedAny}
	 * matrix. Does so by finding all secondary choices selected on the ballot and
	 * adding one to the matrix. If categorizations are being used for secondary
	 * choices, will add one for each category where at least one member who 
	 * is not the same as the primary preference is on the ballot; does so by
	 * calling the {@link BallotStream#getSecondaryOrderedChoices()} method
	 * and adding all non-null values at indices greater than one.
	 */
	private void addToAnyChoiceMatrix() {
		
		if (_info.getPrimaryChoice().equals(StandardBallot.INFORMAL_BALLOT)) {	return;	}		
		MatrixParty		primParty = _rankedAny.get(_info.getPrimChoiceIndex());
				
		String[] choices = _info.getSecondaryOrderedChoices();
		
		/** Adds the {@link #ANY_SPARE_STRING} to count how many ballots are processed. */
		primParty.addSecondPref(ANY_SPARE_STRING);;

		for (int i = 1; i < choices.length && choices[i] != null; i++) {
			primParty.addSecondPref(choices[i]);
		}
		
	}
	
	/**
	 * Adds the current ballot to the {@link #_didCompete} matrix. Does so by checking whether each party
	 * was able to be selected on the current ballot and if both a first and second preference
	 * were competing, adds one to the cell in the matrix.
	 */
	private void addToCompetedMatrix() {
		
		for (int i = 0; i < getPrimSize(); i++) {
			if (!_info.primRunsInCurrentState(getPrimaryOrder().get(i))) continue;
			for (int j = 0; j < getSecSize(); j++) {
				if (!_info.secRunsInCurrentState(getSecondaryOrder().get(j))) continue;
				_didCompete[i][j]++;
			}	
		}
		
	}
	
	/**
	 * Adds the current ballot to the {@link #_couldRankSecond} matrix. Does so by checking who the
	 * first preference was for, and then adding one to the cell for every secondary choice that
	 * could have been picked on the current ballot.
	 */
	private void addToCouldRankSecondMatrix() {
				
		if (_info.ballotIsFormal()) {
			int index = _info.getPrimChoiceIndex();
			for (int j = 0; j < getSecSize(); j++) {
				if (!_info.secRunsInCurrentState(getSecondaryOrder().get(j))) continue;
				_couldRankSecond[index][j]++;	
			}
		}
		
	}
	
	/**
	 * Adds the current ballot to the {@link #_couldRankFirst} matrix. Does so by checking who the
	 * second preference was for, and then adding one to the cell for every first choice that
	 * could have been picked on the current ballot.
	 */
	private void addToCouldRankFirstMatrix() {
		if (_info.ballotIsFormal()) {
			int secIndex = _info.getSecNameToIndex(_info.getSecondaryChoice());
			secIndex = secIndex == -1 ? _couldRankFirst[0].length - 1 : secIndex;
			for (int i = 0; i < getPrimSize(); i++) {
				if (!_info.primRunsInCurrentState(getPrimaryOrder().get(i))) continue;
				_couldRankFirst[i][secIndex]++;
			}
		}
	}
	
	/**
	 * Makes each of the matrices specified by the arguments provided upon
	 * instantiation. The {@link #_info} {@link BallotStream} is not reset after 
	 * matrices are generated, and must be done so by other classes if they wish to
	 * resue the same {@link BallotStream} for other calculations.
	 */
	public void makeMatricies() {
		
		while (_info.hasMoreBallots()) {
			
			_info.nextBallot();
			
			if (_snd) 		addToSecondChoiceMatrix();
			if (_any) 		addToAnyChoiceMatrix();
			if (_cmpt) 		addToCompetedMatrix();
			if (_cldSnd)	addToCouldRankSecondMatrix();
			if (_cldFst)	addToCouldRankFirstMatrix();
			
			if (_info.debugging() && _info.currentBallotNum() % 1000000 == 0) 
				System.err.println(_info.currentBallotNum() + " Ballots Processed at " 
							+ DTF.format(LocalDateTime.now()));
		}
		
		_filled = true;
	}
	
	
	// Methods related to saving matrices to file and making calculations
	// of matrices.

	/** 
	 * Saves a provided 2D String array to the path provided.
	 * @param filename Absolute or relative path to the destination where the
	 * file sould be saved.
	 * @param matrix The matrix being saved to file.
	 * @return Boolean indicating if the matrix was successfully saved.
	 */
	private boolean saveMatrix(String filename, String[][] matrix) {
		File file = new File(filename);
		
		try {
			file.getParentFile().mkdirs();
			file.createNewFile();
			PrintWriter out = new PrintWriter(new FileWriter(file, true));
				
			for (String[] temp : matrix) {
				for (String x : temp) {
					out.print(x + ",");
				}
				out.print("\n");
			}
			out.print("\n");
				
			out.close();
			
			
		} catch (IOException e) {
			e.printStackTrace();
			System.err.println("Error in matrix creation; " + filename + " does not exist.");
			return false;
		}
		
		return true;
	}

	/**
	 * Combines the specified lists into a single 2D array of strings that can be saved to file.
	 * @param parArr Current matrix, in the form of an ArrayList of MatrixParties.
	 * @param primList The name of the final column of the matrix, if the matrix 
	 * is saving the spare slot from a {@link MatrixParty}. Can be left as an empty 
	 * string if the matrix is of size [i][j] where j equals {@link #getSecSize()}
	 * and by proxy {@link BallotStream#getSecNumOptions()}.
	 * @return A two-dimensional string array of the converted data from the matrix.
	 */
	private String[][] changeMatrixToString(int[][] matrix, String finalColName) {
		
		String[][] returnMatrix = new String[matrix.length + 1][matrix[0].length + 1];
		// creates a 2D array for the matrix that has 2 more rows and columns then the
		// newly created partyOrderList ArrayList
		for (int x = 0; x < getSecSize(); x++) {
			returnMatrix[0][x + 1] = getSecondaryOrder().get(x);
		}
		
		if (matrix[0].length > getSecSize()) {
			returnMatrix[0][matrix[0].length] = finalColName;
		}
		
		for (int x = 0; x < getPrimSize(); x++) {
			returnMatrix[x + 1][0] = getPrimaryOrder().get(x);
		}
		
		for (int fst = 0; fst < matrix.length; fst++) {
			// will loop through every ballot for a party in the PartyArray
			for (int snd = 0; snd < matrix[fst].length; snd++) {
				returnMatrix[fst + 1][snd + 1] = Integer.toString(matrix[fst][snd]);
			}
		}
				
		return returnMatrix;

	}

	/**
	 * Returns a 2D String array that transforms the provided 2D int matrix by dividing each
	 * cell by the total number of secondary preferences that a primary preference received.
	 * @param matrix Matrix to be transformed.
	 * @param finalColName The name of the final column if the second dimension of the
	 * provided array is greater than {@link #getSecSize()} and by proxy 
	 * {@link BallotStream#getSecNumOptions()}.
	 * @return String matrix containing the output calculation.
	 */
	private String[][] percentPrimaryVotesMatrix(int[][] matrix, String finalColName) {
		// Calcualtes row sums.
		int[] sums = new int[getPrimSize()]; 
		for (int i = 0; i < getPrimSize(); i++) {
			for (String sec : getSecondaryOrder()) {
				sums[i] += _rankedSecond.get(i).getSecondPref(sec);
			}
			sums[i] += _rankedSecond.get(i).getSpareSlot();
		}
		
		// Instantiates row array
		String[][] rtrn = new String[matrix.length + 1][matrix[0].length + 1];
		
		// Fills columns with column names.
		for (int j = 1; j < getSecSize() + 1; j++) {
			rtrn[0][j] = getSecondaryOrder().get(j - 1);
		}
		
		if (matrix[0].length > getSecSize()) {
			rtrn[0][matrix[0].length] = finalColName;
		}
		
		// Fills rows with row names and populates interior cells.
		for (int i = 0; i < matrix.length; i++) {
			rtrn[i + 1][0] = getPrimaryOrder().get(i);
			for (int j = 0; j < matrix[i].length; j++) {
				if (sums[i] == 0) rtrn[i + 1][j + 1] = "0.0";
				else {
					double val = (double) matrix[i][j] / (double) sums[i];
					rtrn[i + 1][j + 1] = String.format("%.4f", val);
				}
			}
		}
		
		return rtrn;
		
	}
	
	/**
	 * Returns a 2D String array that transforms the provided 2D int matrix by dividing each
	 * cell by the total number of primary preferences that a secondary preference received.
	 * @param matrix Matrix to be transformed.
	 * @param finalColName The name of the final column if the second dimension of the
	 * provided array is greater than {@link #getSecSize()} and by proxy 
	 * {@link BallotStream#getSecNumOptions()}.
	 * @return String matrix containing the output calculation.
	 */
	private String[][] percentSecondaryVotesMatrix(int[][] matrix, String finalColName) {
		// Calculates column sums.
		int[] sums = new int[getSecSize() + 1]; 
		for (int i = 0; i < getPrimSize(); i++) {
			for (int j = 0; j < getSecSize(); j++) {
				sums[j] += _rankedSecond.get(i).getSecondPref(getSecondaryOrder().get(j));
			}
			sums[sums.length - 1] += _rankedSecond.get(i).getSpareSlot();
		}
		
		// Instantiates return matrix.
		String[][] rtrn = new String[matrix.length + 1][matrix[0].length + 1];
		
		
		// Fills columns with column titles
		for (int j = 1; j < getSecSize() + 1; j++) {
			rtrn[0][j] = getSecondaryOrder().get(j - 1);
		}
		
		if (matrix[0].length > getSecSize()) {
			rtrn[0][matrix[0].length] = finalColName;
		}
		
		// Fills rows with row titles and populates matrix.
		for (int i = 1; i < matrix.length + 1; i++) {
			rtrn[i][0] = getPrimaryOrder().get(i - 1);
			for (int j = 1; j < getSecSize() + 1; j++) {
				if (sums[j - 1] == 0) rtrn[i][j] = "0.0";
				else {
					double val = (double) matrix[i - 1][j - 1] / (double) sums[j - 1];
					rtrn[i][j] = String.format("%.4f", val);
				}
			}
		}
		
		return rtrn;
		
	}

	/**
	 * Returns a matrix which contains the name of a category, followed by all the memebers
	 * in the category.
	 * @return Category members matrix.
	 */
	private String[][] categoryMembersMatrix() {
		
		ArrayList<ArrayList<String>> allCatsLists = new ArrayList<>();
		int maxSize = 0;
		
		for (String category : _info.getUniqueCategoriesList()) {
			allCatsLists.add(_info.categoryMembers(category));
			if (allCatsLists.get(allCatsLists.size() - 1).size() > maxSize) {
				maxSize = allCatsLists.get(allCatsLists.size() - 1).size();
			}
		}
		
		String[][] rtrn = new String[allCatsLists.size()][maxSize + 1];
		
		for (int i = 0; i < _info.getUniqueCategoriesList().size(); i++) {
			rtrn[i][0] = _info.getUniqueCategoriesList().get(i) + ":";
			for (int j = 0; j < allCatsLists.get(i).size(); j++) {
				rtrn[i][j + 1] = allCatsLists.get(i).get(j) == null ? "" : allCatsLists.get(i).get(j);
			}
		}
		
		return rtrn;
	}	
	
	public void saveMultipleCalculationsOfMatrix(String filename, int[][] matrix, String finalColName) {
		if (_info.usesCategoriesPrimary() || _info.usesCategoriesSecondary()) {
			saveMatrix(filename, categoryMembersMatrix());
		};
		saveMatrix(filename, changeMatrixToString(matrix, finalColName));
		// Conditional on _snd because both calculation methods require the _rankedSecond 
		// matrix.
		if (_snd) saveMatrix(filename, percentPrimaryVotesMatrix(matrix, finalColName));
		if (_snd) saveMatrix(filename, percentSecondaryVotesMatrix(matrix, finalColName));
	}
	
	/**
	 * Saves all matrices in the {@link Matrices} into the {@link BallotStream}'s 
	 * {@link BallotStream#getOutputLocation()}, in the subdirectory "matrices".
	 */
	public void saveMatrices() 			{ saveMatrices(_info.getOutputLocation() + "//matrices//"); }
	
	/**
	 * Saves all matrices in the {@link Matrices} into the to the filePath provided; 
	 * the filePath is assumed to include "//" at the end of the last subdirectory so as to allow
	 * prefixing to the front of the file names if desired.
	 */
	public void saveMatrices(String filePath) {
		if (_snd) {
			String filename = filePath + "Matrix Second Ranked " + _info.getElectionName() + ".csv";
			saveMultipleCalculationsOfMatrix(filename, getRankedSecondAsIntArr(), "No Second Pref");
		}
		if (_any) {
			saveMultipleCalculationsOfMatrix(filePath + "Matrix Any Ranked " + _info.getElectionName() + ".csv", 
					getRankedAnyAsIntArr(), "Total Votes");
		}
		if (_cmpt) {
			saveMatrix(filePath + "Matrix Total Competed " + _info.getElectionName() + ".csv", 
					changeMatrixToString(_didCompete, ""));
		}
		if (_cldSnd) {
			saveMatrix(filePath + "Matrix First Preference Competed " + _info.getElectionName() + ".csv", 
					changeMatrixToString( _couldRankSecond, ""));
		}
		if (_cldFst) {
			saveMatrix(filePath + "Matrix Second Preference Competed " + _info.getElectionName() + ".csv", 
					changeMatrixToString(_couldRankFirst,  "No Second Preference"));
		}
	}

	
	// Methods for outside classes to get information with which to perform calculations.
	
	/**
	 * Returns the total number of valid votes cast in the election.
	 * @return Total number of valid votes
	 */
	public int totalVotesCast() {
		if (!_filled) 	return -1;
		if (!_snd) 		return -1;
		if (_primaryTotalVotes != null) {
			int sum = 0;
			for (int i : _primaryTotalVotes) sum += i;
			return sum;
		} else if (_secondaryTotalVotes != null) {
			int sum = 0;
			for (int i : _secondaryTotalVotes) sum += i;
			return sum;
		} else {
			totalPrimaryVotesByOption();
			return totalVotesCast();
		}
	}
	
	/**
	 * Returns a list of the total number of primary votes each primary option earned;
	 * will be in the same order as {@link #getPrimaryOrder()} and by proxy
	 * {@link BallotStream#getPrimOptions()}.
	 * @return List of total primary votes by primary option.
	 */
	public ArrayList<Integer> totalPrimaryVotesByOption() {
		if (!_filled) return null;
		if (_primaryTotalVotes != null) return _primaryTotalVotes;
		_primaryTotalVotes = new ArrayList<>();
		for (int i = 0; i < getPrimSize(); i++) {
			int sum = 0;
			for (Entry<String, Integer> e : _rankedSecond.get(i).entrySet()) {
				sum += e.getValue();
			}
			_primaryTotalVotes.add(sum);
		}
		return _primaryTotalVotes;
	}
	
	/**
	 * Returns a list of the total number of secondary votes each secondary option earned;
	 * will be in the same order as {@link BallotStream#getSecOptions()} and
	 * {@link #getSecondaryOrder()}, with the addition of a single value at the end 
	 * for ballots with no secondary preference.
	 * @return List of total secondary votes by secondary option.
	 */
	public ArrayList<Integer> totalSecondaryVotesByOption() {
		if (!_filled) 		return null;
		if (_secondaryTotalVotes != null) return _secondaryTotalVotes;
		_secondaryTotalVotes = new ArrayList<>();
		for (String opt : getSecondaryOrder()) {
			int sum = 0;
			for (MatrixParty cur : _rankedSecond) {
				sum += cur.getSecondPref(opt);
			}
			_secondaryTotalVotes.add(sum);
		}
		int sum = 0;
		for (MatrixParty cur : _rankedSecond) {
			sum += cur.getSpareSlot();
		}
		_secondaryTotalVotes.add(sum);
		
		return _secondaryTotalVotes;
	}
	
	/**
	 * Transforms an ArrayList of {@link MatrixParty} into a 2D integer array.
	 * Used by {@link #getRankedSecondAsIntArr()} and {@link #getRankedAnyAsIntArr()}.
	 * @param matrix ArrayList of {@link MatrixParty} to be transformed
	 * @return Transformed array.
	 */
	private int[][] makeArLMPIntoIntArr(ArrayList<MatrixParty> matrix) {
		int[][] mtrx = new int[getPrimSize()][getSecSize() + 1];
		for (int i = 0; i < getPrimSize(); i++) {
			for (int j = 0; j < getSecSize(); j++) {
				mtrx[i][j] = matrix.get(i).getSecondPref(getSecondaryOrder().get(j));
			}
			mtrx[i][getSecSize()] = matrix.get(i).getSpareSlot();
		}
		
		return mtrx;
	}
	
	/**
	 * @return The {@link #_rankedSecond} matrix, if it was created on
	 * instantiation and the matrices have been filled.
	 */
	public ArrayList<MatrixParty> getRankedSecond() { return _filled && _snd ? _rankedSecond : null; }
	
	/**
	 * @return An integer array version of the {@link #_rankedSecond} matrix, 
	 * if it was created on instantiation and the matrices have been filled.
	 */
	public int[][] getRankedSecondAsIntArr() { return _filled && _snd ? makeArLMPIntoIntArr(_rankedSecond) : null; }
	
	/**
	 * @return The {@link #_rankedAny} matrix, if it was created on
	 * instantiation and the matrices have been filled.
	 */
	public ArrayList<MatrixParty> getRankedAny() { return _filled && _any ? _rankedAny : null; }

	/**
	 * @return An integer array version of the {@link #_rankedAny} matrix, 
	 * if it was created on instantiation and the matrices have been filled.
	 */
	public int[][] getRankedAnyAsIntArr() { return _filled && _any ? makeArLMPIntoIntArr(_rankedAny) : null; }
	
	/**
	 * @return The {@link #_didCompete} matrix, if it was created on
	 * instantiation and the matrices have been filled.
	 */
	public int[][] getCompeted() { return _filled && _cmpt ? _didCompete : null; }
	
	/**
	 * @return The {@link #_couldRankSecond} matrix, if it was created on
	 * instantiation and the matrices have been filled.
	 */
	public int[][] getCouldRankSecond() { return _filled && _cldSnd ? _couldRankSecond : null; }
	
	/**
	 * @return The {@link #_couldRankFirst} matrix, if it was created on
	 * instantiation and the matrices have been filled.
	 */
	public int[][] getCouldRankFirst() { return _filled && _cldFst ? _couldRankSecond : null; }
	
	
	// Methods about the options and their ordering.
	
	/**
	 * @return The number of primary options.
	 */
	public int getPrimSize() {
		return _info.getPrimNumOptions();
	}

	/**
	 * @return The number of secondary options.
	 */
	public int getSecSize() {
		return _info.getSecNumOptions();
	}
	
	/**
	 * @return The ordered list of primary options, as defined by {@link BallotStream#getPrimOptions()}
	 */
	public ArrayList<String> getPrimaryOrder() {
		return _info.getPrimOptions();
	}
	
	/**
	 * @return The ordered list of secondary options, as defined by {@link BallotStream#getSecOptions()}
	 */
	public ArrayList<String> getSecondaryOrder(){
		return _info.getSecOptions();
	}

}
